/*!
GPII Matchmaker Framework - Utilities

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2014 Raising the Floor - international

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

The research leading to these results has received funding from the European Union's
Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 289016.

You may obtain a copy of the License at
https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

var fluid = fluid || require("infusion"),
    gpii = fluid.registerNamespace("gpii"),
    $ = fluid.registerNamespace("jQuery");

(function () {

    "use strict";
    fluid.registerNamespace("gpii.matchMakerFramework.utils");

    /**
     * Helper function for computeAndOntologizeCapabilitiesFromSettingsHandler. Grabs the capabilities (incl. those from the
     * capabilities transformations) for a single settings handler. Returns them in the ontology
     * provided via the transform spec
    */
    gpii.matchMakerFramework.utils.computeAndOntologizeCapabilitiesFromSettingsHandler = function (settingsHandler, transformSpec) {
        var inputPaths = fluid.model.transform.collectInputPaths(settingsHandler.capabilitiesTransformations || {});
        inputPaths = inputPaths.concat(fluid.makeArray(settingsHandler.capabilities));

        // Input paths are flat so need to be transformed into hierarchical
        var skel = gpii.matchMakerFramework.utils.pathsToSkeleton(inputPaths, true);
        var hskeleton = fluid.model.transformWithRules(skel, transformSpec);

        return gpii.matchMakerFramework.utils.computeLeaves(hskeleton);
    };

    /*
     * Given a solution entry, all the capabilities of that solution will be calculated based on
     * input paths in the transformations (specified in the capabilitiesTransformations block) and
     * on the list in the capabilities block of that solution. The collected capabilities will be
     * transformed via the transformspec, and the result will be an array list of el-paths in the
     * ontology transformed to.
     *
     * @solution {Object} A single solution entry, as can be found in the solutions registry
     * @transformSpec {Object} transformation rules to transform the input paths from the solution
     *    registry format into the format desired in the output array. If if one would like the result
     *    as a list of ISO24751 el-paths and the solutionsregistry transformations are given in
     *    the flat format, a transformation rules for 'flat' to ISO24751 should be given
     * @result {Array} An array of el-paths to all the input paths of the capabilitiesTransformations
     *    concatenated with the list given in the capabilities block of the solution entry.
    */
    gpii.matchMakerFramework.utils.computeAndOntologizeCapabilitiesFromSolution = function (solution, transformSpec) {
        var settingsHandlerBlocks = [];
        fluid.each(solution.settingsHandlers, function (handlerBlock) {
            var capabilities = gpii.matchMakerFramework.utils.computeAndOntologizeCapabilitiesFromSettingsHandler(handlerBlock, transformSpec);
            settingsHandlerBlocks = settingsHandlerBlocks.concat(capabilities);
        });
        return settingsHandlerBlocks;
    };

    /*
     * Helper function for gpii.matchMakerFramework.utils.computeLeaves - see description there
     */
    var computeLeavesImpl = function (model, path, paths) {
        fluid.each(model, function (value, key) {
            var newPath = fluid.pathUtil.composePath(path, key.toString());
            if (fluid.isPrimitive(value)) {
                paths.push(newPath);
            }
            else {
                computeLeavesImpl(value, newPath, paths);
            }
        });
    };

    /*
     * Function to extract all leaves (ie. primitive end points) from an object. More specifically,
     * it takes a object (eg. prefs set) and finds all leaves - for each leaf found the path is
     * to an array as an el-path, one path for each leaf.
     *
     * @model {Object} the object from which to subtract leaves
     * @return {Array} an array of el-paths, one entry for each leaf found in the object
     */
    gpii.matchMakerFramework.utils.computeLeaves = function (model) {
        var paths = [];
        computeLeavesImpl(model, "", paths);
        return paths;
    };

    /*
     * Given a array of el-paths, this function creates an object with a structure that includes
     * all the el-paths in the array. Each of the entries will have the value passed as parameter or
     * defaulting to {} (ie. the empty object);
     *
     * @paths {Array} an array of el-paths that should be present in the resulting object
     * @value {any} the value that should be assigned to each of the keys given in the el-path array,
     *      if no @value is given, this defaults to the empty object ({})
     * @return {Object} and object with a structure containing all the el-paths, where each path has
     *     the value given in the parameter.
     */
    gpii.matchMakerFramework.utils.pathsToSkeleton = function (paths, value) {
        var togo = {};
        for (var i = 0; i < paths.length; ++ i) {
            var path = paths[i];
            var existing = fluid.get(togo, path, fluid.model.escapedGetConfig);
            if (!existing) {
                fluid.set(togo, path, value || {}, fluid.model.escapedSetConfig);
            }
        }
        return togo;
    };

    /*
     * Given a list of solutions, calculate the capabilities and generate a skeleton based on those.
     *
     * @solutions {Object} list of solution entries in the same format as the solutions registry
     * @transformSpec {Object} transformation rules to translate from the format the input paths are
     *     given in in the solutions entries' capabilitiesTransformations block, to the ontology
     *     that the skeleton should be in
     * @return {Object} an object listing the same solutions as the input payload, but where each
     *     solution block instead contains three keys: 'solution' which contains the original solution
     *     entry. 'skeleton' which contains the capabilities of the solution. 'index' which contains
     *     the solution id.
     */
    gpii.matchMakerFramework.utils.expandSolutions = function (solutions, transformSpec) {
        return fluid.transform(solutions, function (solution, solutionId) {
            var paths = gpii.matchMakerFramework.utils.computeAndOntologizeCapabilitiesFromSolution(solution, transformSpec);
            var skeleton = gpii.matchMakerFramework.utils.pathsToSkeleton(paths);

            return {
                solution: solution,
                skeleton: skeleton,
                index: solutionId
            };
        });
    };

    /*
     * Function that takes a MM payload set as input that *includes* an entry of
     * preferences in a hierarchical format, as well as a strategy for selecting solutions
     * and a set of transformations rules between ontologies.
     *
     * @data {Object} a match maker output input payload that includes a translation of the
     *     preferences in an hierarchical ontology, keyed by 'hierarchicalPrefs'.
     * @strategy {function} the strategy to use to select which solutions should be configured and
     *     and launched on the system
     * @transformSpec {Object} Transformation rules FROM the format used in the input paths of the
     *     solutions registry capability transformations TO the format in which the
     *     settings of hierarchicalPrefs in the data argument are given
     * @return {Object} An object keyed by contexts and where the values are arrays of solutions
     *     to launch in that context
     */
    gpii.matchMakerFramework.utils.disposeSolutions = function (data, strategy, transformSpec) {
        var solrecs = gpii.matchMakerFramework.utils.expandSolutions(data.solutionsRegistryEntries, transformSpec);
        var togo = {};
        // calculate match for each of the contexts
        fluid.each(data.hierarchicalPrefs.contexts, function (context, contextId) {
            // add implicit priorities based on which applications the user has application
            // specific settings for
            gpii.matchMakerFramework.utils.addPriorityFromApplicationSettings(context.preferences, solrecs);

            // add users explicit application priorities to the solrecs object
            gpii.matchMakerFramework.utils.parsePriorities(context, contextId, data, solrecs);

            var leaves = gpii.matchMakerFramework.utils.computeLeaves(context.preferences);
            var disposed = strategy(leaves, solrecs, data, contextId);
            togo[contextId] = [];
            fluid.each(disposed, function (solrec, solid) {
                if (solrec.disposition === "accept") {
                    togo[contextId].push(solid);
                }
            });
        });
        return togo;
    };

    // true if one of the values matches across the two arrays (ignoring the indexing)
    gpii.matchMakerFramework.utils.containsSameValue = function (arr1, arr2) {
        var obj1 = {};
        var i;
        // convert arr1 to object for fast and easy comparison
        for (i in arr1) {
            obj1[arr1[i]] = true;
        }
        // compare:
        for (i in arr2) {
            if (arr2[i] in obj1) {
                return true;
            }
        }
        return false;
    };

    /**
     */
    gpii.matchMakerFramework.utils.disposeFromPriority = function (solrecs, data) {
        // sort into prioritized map: 1024: [sola, solb], 200 [solc]
        var prioritiesMap = {};
        fluid.each(solrecs, function (sol) {
            if (sol.priority) {
                fluid.set(prioritiesMap, [sol.priority, sol.index], true);
            }
        });
        // sort priority entries desc
        var priorities = Object.keys(prioritiesMap).sort(function (a, b) { return b - a; });
        // for each priority bucket:
        for (var i = 0; i < priorities.length; i++) {
            var priority = priorities[i];
            var sols = prioritiesMap[priority];

            // for each solution as sol
            for (var solutionId in sols) {
                var tied = [];
                var solutionType = data.solutionTypes[solutionId];
                // if a disposition is already decided for this solution, or if priority has been
                // removed (in case of ties), ignore it.
                if (solrecs[solutionId].disposition || !solrecs[solutionId].priority) {
                    continue;
                }
                // check if there are any similar typed solution with same priority:
                // for each remaining solution as rsol
                // delete sols[solutionId];
                for (var otherId in sols) {
                    // if a disposition is already decided for this solution, or if priority has been
                    // removed (in case of ties), ignore it.
                    if (otherId === solutionId || solrecs[otherId].disposition || !solrecs[otherId].priority) {
                        continue;
                    }
                    // if solutions are of equal type:
                    if (gpii.matchMakerFramework.utils.containsSameValue(solutionType, data.solutionTypes[otherId])) {
                        // since we tie with another solution, resolve by other disposal means
                        // delete solrecs[otherId].priority;
                        tied.push(otherId);
                    }
                }
                // before accepting a solution, make sure all solutions of that type are marked reject
                gpii.matchMakerFramework.utils.rejectFromTypes(data.solutionTypes[solutionId],
                        data.solutionTypeMapping, solrecs,
                        "Another solution of same type with higher priority was found.");

                // if no ties, mark the current solution as "accept"
                if (tied.length === 0) {
                    solrecs[solutionId].disposition = "accept";
                    solrecs[solutionId].dispositionReason = "Has a higher priority (" + priority +
                        ") than any solution of the same type";
                } else {
                    // if there are ties, we "unreject" all of them, removing their disposition completely
                    // so they can be tiebreaked by other disposal means (such as via the canopy)
                    tied.push(solutionId);
                    fluid.each(tied, function (tiedSolutionId) {
                        delete solrecs[tiedSolutionId].priority;
                        delete solrecs[tiedSolutionId].disposition;
                        delete solrecs[tiedSolutionId].dispositionReason;
                    });
                }
            }
        }
    };

    /**
     * Rejects all solutions of a given type. This is useful for ensuring that a user does not
     * get eg. multiple versions of screenReader launched
     * doc: modifies the solrecs object
     */
    gpii.matchMakerFramework.utils.rejectFromTypes = function (types, solutionTypeMapping, solrecs, disposeReason) {
        fluid.each(types, function (type) {
            for (var solutionId in solutionTypeMapping[type]) {
                var sol = solrecs[solutionId];
                if (!sol.disposition) {
                    sol.disposition = "reject";
                    sol.dispositionReason = disposeReason || "Solution rejected due to its type of " + type;
                }
            }
        });
    };

    gpii.matchMakerFramework.utils.parsePriorities = function (context, contextId, data, solrecs) {
        // for each entry in the metadata block:
        fluid.each(context.metadata, function (metadata) {
            if (metadata.type === "priority") {
                fluid.each(metadata.scope, function (applicationId) {
                    // set the priority of the application if it's part of our solrecs list:
                    var solrec = solrecs[applicationId.substr("http://registry.gpii.net/applications/".length)];
                    if (solrec) {
                        solrec.priority = metadata.value;
                    }
                });
            }
        });
    };

    gpii.matchMakerFramework.utils.addPriorityFromApplicationSettings = function (preferences, solrecs) {
        fluid.each(preferences.applications, function (value, applicationId) {
            var sol = solrecs[applicationId];
            // If solution is available on the system, and doesn't already have higher priority
            if (sol && (!sol.priority || sol.priority < 512)) {
                sol.priority = 512;
            }
        });
    };

    /*
     * Function to build the payload required to be the output from the matchmaker framework
     *
     * @fullModel {Object} The full input sent to the MM
     * @disposed {Object} Object with keys of context-ids. Each value should be an array listing
     *     the disposed solutions
     * @return {Object} The data arranged to be compatible with the required MM format
     */
    gpii.matchMakerFramework.utils.buildReturnPayload = function (fullModel, disposed) {
        var togo = {
            inferredConfiguration: {}
        };

        fluid.each(disposed, function (solArray, contextId) {
            togo.inferredConfiguration[contextId] = {
                applications: {}
            };
            var appBlock = togo.inferredConfiguration[contextId].applications;
            fluid.each(solArray, function (solutionId) {
                var content = {
                    active: true,
                    settings: fullModel.preferences.contexts[contextId].preferences
                };
                appBlock[solutionId] = content;
                // TODO: add metadata sections
            });

            // add conditions if they exist:
            if (fullModel.preferences.contexts[contextId].conditions) {
                togo.inferredConfiguration[contextId].conditions = fullModel.preferences.contexts[contextId].conditions;
            }
        });
        return togo;
    };

    /*
     * Merges a set of common term preferences with an already existing preferences set. This is
     * used when merging inferred common terms from the MM input payload with the already existing
     * common terms of the NP set. This happens for all the context blocks (for which inferred
     * common terms exist). Existing common terms take priority over the inferred terms
     *
     * @preferences {Object} A needs and Preferences set (including the context blocks)
     * @inferred {Object} Inferred common terms, as provided in the MM input
     * @return {Object} A copy of the preferences object with the inferred common terms merged in
     */
    gpii.matchMakerFramework.utils.addInferredCommonTerms = function (preferences, inferred) {
        var togo = fluid.copy(preferences);
        fluid.each(inferred, function (context, contextId) {
            var tcont = togo.contexts[contextId];
            fluid.each(context, function (settings) {
                tcont.preferences = $.extend(true, settings, tcont.preferences);
            });
        });
        return togo;
    };

    /**
     * Take a contextual section of an NP set
     */
    gpii.matchMakerFramework.utils.addSolutionTypeInformation = function (payload, transformSpec) {
        fluid.each(payload.solutionsRegistryEntries, function (entry, entryId) {
            // first get an array of what solution types the current entry is:
            var solutionTypes = gpii.matchMakerFramework.utils.computeAndOntologizeCapabilitiesFromSolution(entry, transformSpec);
            fluid.set(payload, [ "solutionTypes", entryId], solutionTypes);
            // now add solution ID to the return array in the appropriate places:
            for (var i in solutionTypes) {
                // add solution ID to the solution type
                fluid.set(payload, ["solutionTypeMapping", solutionTypes[i], entryId], true);
            }
        });
    };
})();

