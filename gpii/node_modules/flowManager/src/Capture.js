/**
 * GPII snapshot Handler
 *
 * Copyright 2014 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/gpii/universal/LICENSE.txt
 */
"use strict";

var fluid = require("infusion"),
    gpii = fluid.registerNamespace("gpii");

fluid.defaults("gpii.flowManager.capture", {
    gradeNames: ["fluid.component"],
    events: {
        onSolutionsForCurrentDevice: null,
        onCaptureSettingsForCurrentDevice: null
    },
    listeners: {
        onSolutionsForCurrentDevice: [
            {
                funcName: "gpii.lifecycleManager.getDeviceContextPromise",
                args: ["{flowManager}.deviceReporter"]
            },
            {
                funcName: "gpii.flowManager.getSolutionsPromise",
                args: [ "{flowManager}.solutionsRegistryDataSource", "{arguments}.0"]
            },
            {
                funcName: "fluid.toPromise",
                args: ["{arguments}.0.solutionsRegistryEntries"]
            }
        ],
        onCaptureSettingsForCurrentDevice: [
            {
                func: "{that}.getInstalledSolutions"
            },
            {
                func: "{that}.captureSystemSettings",
                args: ["{arguments}.0", "{arguments}.1"]
            },
            {
                func: "gpii.flowManager.formatRawCapturedSettings",
                args: ["{arguments}.0"]
            }
        ]
    },
    invokers: {
        getInstalledSolutions: {
            funcName: "gpii.flowManager.getInstalledSolutions",
            args: ["{that}"]
        },
        getSystemSettingsCapture: {
            funcName: "gpii.flowManager.getSystemSettingsCapture",
            args: ["{that}.events.onCaptureSettingsForCurrentDevice", "{arguments}.0"] // Options
        },
        captureSystemSettings: {
            funcName: "gpii.flowManager.captureSystemSettings",
            args: ["{lifecycleManager}.invokeSettingsHandlerGet", "{lifecycleManager}.variableResolver",
                "{lifecycleManager}.userSession.localResolver", "{arguments}.0", "{arguments}.1"]
        }
    }
});

gpii.flowManager.getInstalledSolutions = function (that) {
    return fluid.promise.fireTransformEvent(that.events.onSolutionsForCurrentDevice);
};

/**
 * This main API entry point for capturing settings from a system or computer. This captures
 * the actual settings on the device, so it assumed to be running in a local untrusted flow
 * manager.
 *
 * @param {Event} onCaptureSettingsForCurrentDevice - The transforming promise chain
 * @param {Object} options - Options for this chain.
 * @param {Array} options.solutionsList - An array of solution IDs to filter by when
 * retreiving settings. If this option is not included, all available settings will be
 * returned. ex: `["com.microsoft.windows.mouseSettings", "com.freedomscientific.jaws"]`.
 * @return {Promise} A promise resolved with the payload of captured system settings.
 */
gpii.flowManager.getSystemSettingsCapture = function (onCaptureSettingsForCurrentDevice, options) {
    return fluid.promise.fireTransformEvent(onCaptureSettingsForCurrentDevice,
        {}, options);
};

/**
 * This function invokers a settings handler to fetch settings, but wraps the processing and reports
 * back any failures in an `isError: true` json block.
 *
 * @param {Function} invokeSettingsHandlerGet - The get function from the appropriate settings handler.
 * @param {String} solutionID - The dotted solution id, ex `com.freedomscientific.jaws`
 * @param {Object} handlerSpec - TODO, exactly how much of the solutions entry block is this?
 * @return {Object} The returned settings, or an error block with debugging information.
 */
gpii.flowManager.capture.safeHandlerGet = function (invokeSettingsHandlerGet, solutionID, handlerSpec) {
    var promiseTogo = fluid.promise();
    try {
        invokeSettingsHandlerGet(solutionID, handlerSpec).then(function (data) {
            // TODO In progress refactoring back to gpii-windows
            // Fix up the nativeWindows and SPI Settings Handlers
            // var filteredData = gpii.flowManager.filterInvokeSettingsHandlersReturn(data, handlerSpec);
            promiseTogo.resolve(data);
        }, function (err) {
            promiseTogo.resolve({
                solutionId: solutionID,
                handlerSpec: handlerSpec,
                isError: true,
                message: "inner promise error",
                err: err
            });
        });
    }
    catch (err) {
        promiseTogo.resolve({
            solutionId: solutionID,
            handlerSpec: handlerSpec,
            isError: true,
            message: "outer try error",
            err: err
        });
    }
    return promiseTogo;
};

gpii.flowManager.capture.fetchAllSettingsForSolution = function (invokeSettingsHandlerGet, solution, solutionID, resolver) {
    var settingsPromisesTogo = [];

    var newSolution = gpii.lifecycleManager.transformSolutionSettings(solution, gpii.settingsHandlers.changesToSettings);

    // TODO In progress refactoring back to gpii-windows
    // if (solutionID === "com.freedomscientific.jaws") {
    //     newSolution = gpii.flowManager.jawsVoiceProfileAdjustment(newSolution, localResolver);
    // }

    fluid.each(newSolution.settingsHandlers, function (handlerSpec) {
        //if applicationSettings is unspecified, dont attempt to get settings
        if (!handlerSpec.supportedSettings) {
            return;
        }
        handlerSpec.settings = handlerSpec.supportedSettings;
        // TODO There is some in progress refactoring that happened here to update spiSettingsHandler.
        // No longer here, but this is a reminder to resolve it when there are acceptance tests for the SPI settings capture.
        handlerSpec = resolver.resolve(handlerSpec, {});
        settingsPromisesTogo.push(gpii.flowManager.capture.safeHandlerGet(invokeSettingsHandlerGet, solutionID, handlerSpec));
    });
    return settingsPromisesTogo;
};

/**
 * Runs through all the solutions currently available on the system, pulls the current
 * setting for each supportedSetting and returns them in an object. Primary use case
 * is for backing Capture tools that would allow a user to set up their GPII profile
 * starting with the current settings for their applications on the local machine.
 *
 * @param {lifecycleManager.invokeSettingsHandlerGet} invokeSettingsHandlerGet - Invoker from the `lifecycleManager`
 * necessary for extracting settings from a solution and it's spec.
 * @param {lifecycleManager.variableResolver} resolver - Resolver for looking up handler specifications
 * @param {lifecycleManager.userSession.localResolver} localResolver - Resolver for expanding configuration file paths
 * from the solutions registry.
 * @param {Object} solutions - Solutions registry entries for solutions available on the current machine.
 * @param {Object} options - Extra options for processing.
 * @param {Array} options.solutionsList - If provided, only solutions in this list of `solutionsID`s will
 * be captures. Example:
 *
 * '''json
 * ["com.microsoft.windows.cursors", "com.freedomscientific.jaws"]
 * '''
 * @return {fluid.promise} Returns a promise resolving with the entire system settings capture.
 */
gpii.flowManager.captureSystemSettings = function (invokeSettingsHandlerGet, resolver, localResolver, solutions, options) {
    var handlerGetPromises = [];

    var solutionsToFetch = solutions;
    if (options.solutionsList) {
        solutionsToFetch = {};
        fluid.each(solutions, function (solution, solutionID) {
            if (options.solutionsList.indexOf(solutionID) >= 0) {
                solutionsToFetch[solutionID] = solution;
            }
        });
    }

    fluid.each(solutionsToFetch, function (solution, solutionID) {
        var nextPromises = gpii.flowManager.capture.fetchAllSettingsForSolution(invokeSettingsHandlerGet, solution, solutionID, resolver);
        handlerGetPromises = handlerGetPromises.concat(nextPromises);
    });

    return fluid.promise.sequence(handlerGetPromises);
};

/**
 * The raw return payload from the capture promise sequence looks like:
 * '''json
 *       [
 *           {
 *               "fakemag1": [
 *                   {
 *                       "settings": {
 *                           "magnification": 2
 *                       }
 *                   }
 *               ]
 *           },
 *           {
 *               "fakemag1": [
 *                   {
 *                       "settings": {
 *                           "invert": true
 *                       }
 *                   }
 *               ]
 *           },
 *           {
 *               "fakemag2": [
 *                   {
 *                       "settings": {
 *                           "magnification": 2,
 *                           "invert": true
 *                       }
 *                   }
 *               ]
 *           }
 *       ]
 * '''
 *
 * and we want:
 * '''json
 *       {
 *           "fakemag1": {
 *               "magnification": 2,
 *               "invert": true
 *           },
 *           "fakemag2": {
 *               "magnification": 2,
 *               "invert": true
 *           }
 *       }
 * '''
 *
 * @param {Object} data - The raw captured data.
 * @return {Object} Returns a new payload with collapsed data, and multiple settings handler
 * results for the same solution merged together.
 */
gpii.flowManager.formatRawCapturedSettings = function (data) {
    var togo = {};
    fluid.each(data, function (sequenceItem) {
        if (sequenceItem.isError) {
            fluid.log("Error capturing settings for: ", sequenceItem);
            return;
        }
        fluid.each(sequenceItem, function (item, key) {
            if (!togo[key]) {
                togo[key] = {};
            }
            fluid.each(item[0].settings, function (value, settingId) {
                togo[key][settingId] = value;
            });
        });
    });
    return togo;
};
